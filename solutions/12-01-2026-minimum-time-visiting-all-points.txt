Problem: Minimum Time Visiting All Points

Approach: To move from one point to the next, I calculated the horizontal distance `dx` and vertical distance `dy`.
Since diagonal moves cover both x and y in one step, the optimal strategy is to move diagonally as much as possible.
The number of diagonal steps is the minimum of `dx` and `dy`.
After using diagonal moves, the remaining distance is covered using straight moves.
The total time for each move is therefore `max(dx, dy)`, which I accumulated for all consecutive point pairs.

Time Complexity: O(n) 
Space Complexity: O(1)

```cpp

class Solution {
public:
    int minTimeToVisitAllPoints(vector<vector<int>>& points)
    {
        int time = 0;

        for (int i = 1; i < points.size(); i++)
        {
            int dx = abs(points[i][0] - points[i - 1][0]);
            int dy = abs(points[i][1] - points[i - 1][1]);

            if (dx == dy)
            {
                time += dx;
            }
            else
            {
                int diagonal = min(dx, dy);
                time += diagonal;
                time += abs(dx - dy);
            }
        }

        return time;
    }
};
