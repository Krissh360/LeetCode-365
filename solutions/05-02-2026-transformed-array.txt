Problem: Construct Transformed Array

Approach:
The task is to create a new array where each element is determined by making a circular jump from the current index based on the value present at that index.

For every index i, we move nums[i] steps forward (or backward if the value is negative) in a circular manner and select the element at the new position.

Since this movement can go out of bounds or become negative, proper modular arithmetic is required to wrap around the array safely.

The expression:

((i + nums[i]) % n + n) % n

ensures that:
- The index always remains within the valid range [0, n-1]
- Negative jumps are handled correctly
- The array behaves like a circular structure

We store the selected values in a result array and return it.

This solution runs in a single pass over the array and is easy to reason about.

Time Complexity: O(n)
Space Complexity: O(n)


```cpp
class Solution {
public:
    vector<int> constructTransformedArray(vector<int>& nums) {
        
        int n = nums.size();
        vector<int> result(n);

        for (int i = 0; i < n; i++)
        {
            result[i] = nums[((i + nums[i]) % n + n) % n];
        }
        
        return result;
    }
};