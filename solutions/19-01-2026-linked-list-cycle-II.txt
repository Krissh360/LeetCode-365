Problem: Linked List Cycle II 

## Approach
Used Floydâ€™s cycle detection algorithm with two pointers.
First, slow moves one step and fast moves two steps to check if a cycle exists.
If they meet, it confirms a loop.

To find the starting node of the cycle, I placed a new pointer at the head.
Then moved both this pointer and the slow pointer one step at a time.
The point where they meet is the exact start of the cycle.

This works because the distance from head to cycle start equals the distance from meeting point to cycle start inside the loop.

Time Complexity: O(n) 
Space Complexity: O(1)

```cpp

class Solution {
public:
    ListNode *detectCycle(ListNode *head) {

        ListNode *slow = head;
        ListNode *fast = head;

        while (fast != NULL && fast -> next != NULL)
        {
            slow = slow -> next;
            fast = fast -> next -> next;

            if (slow == fast)
            {
                ListNode *temp = head;

                while (temp != slow)
                {
                    temp = temp -> next;
                    slow = slow -> next;
                }

                return temp;
            }
        }

        return NULL;
        
    }
};