Problem: Minimum removals to balance array

Approach:
The goal is to remove the minimum number of elements so that the remaining array satisfies the condition:
max_element <= min_element * k

This means that in the final array, the largest number should not exceed k times the smallest number.

To make this easier to reason about, the first step is to sort the array. Once sorted, the smallest and largest elements of any valid group will lie at the ends of a subarray.

Now the problem reduces to finding the largest contiguous subarray where:
nums[j] <= nums[i] * k

This can be efficiently done using the two-pointer (sliding window) technique.

We maintain two pointers:
i -> start of the window (smallest element in the current group)
j -> end of the window (largest element in the current group)

As j moves forward, if the condition breaks (nums[j] > nums[i] * k), we move i forward until the condition becomes valid again.

At every step, we track the maximum size of such a valid window.

That window represents the largest group we can keep without violating the rule.
All other elements must be removed.

So, the minimum removals required = total elements âˆ’ size of the largest valid window.

Time Complexity: O(n log n)
Space Complexity: O(1)

```cpp

class Solution {
public:
    int minRemoval(vector<int>& nums, int k) {

        int n = nums.size();
        if (n == 1) return 0;
        int i = 0, j = 0, mxsize = 0;

        sort(nums.begin(), nums.end());

        while (j < n)
        {
            while ((long long)nums[i]*k < (long long)nums[j])
            {
                i++;
            }

            mxsize = max(mxsize, j-i+1);
            j++;
        }

        return n-mxsize;
    }
};